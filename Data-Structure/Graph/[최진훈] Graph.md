# 목차 
[1. Graph](#Graph) <br>
[2. 용어](#용어) <br>
[3. 구현 방법](#구현-방법) <br>
[4. 그래프의 종류](#그래프의-종류) <br>
[5. 그래프 탐색](#그래프-탐색) <br>


# Graph
* 그래프는 정점(vertex)과 간선(edge)으로 이루어진 자료구조
* 즉, 여러 정점들 간의 관계를 표현하는 조직도
* 트리 구조와 유사하지만 부모-자식 관계가 존재 x

# 용어
1. 정점 vertex = 노드(node), 데이터가 저장되는 그래프 기본 원소
2. 간선 edge = 링크(link), 정점간의 관계를 나타냄
3. 인접 정점 adjacent vertex = 간선에 의해 연결된 정점 (A, C 는 서로 인접 정점)
4. 단순 경로 simple path = 동일한 간선을 지나지 않는 경로
5. 차수 degree = 무방향 그래프에서 한 정점에 인접한 정점의 수 (C의 차수는 2)
6. 진출 차수 out-degree : 방향 그래프에서 한 정점에서 다른 정점으로 나가는 간선의 수
7. 진입 차수 in-degree : 방향 그래프에서 외부에서 한 정점으로 들어오는 간선의 수

# 구현 방법
## 인접 행렬(Adjacency Matrix)
* 2차원 배열로 그래프를 구현하는 방식
*  간선이 존재하는 두 정점 칸은 1로 없는 칸은 0으로 채우고 만약 가중치가 다른 그래프라면 해당 가중치 값을 기입
* 2차원 배열상에 그래프의 모든 정보가 담겨있기 때문에 간선의 존재 여부나 가중치를 바로 참조 가능 -> O(1)
* N^N 크기의 2차원 배열을 사용하기 때문에 메모리를 효율적으로 사용 불가능
* 모든 간선 정보를 대입하는데 걸리는 시간 O(N^N)

## 인접 리스트(AdJacency List)
* 정점에 연결되어 있는 정점들만 리스트로 나타내는 그래프 표현 방식
* 필요한 만큼의 메모리만 사용하기 떄문에 메모리 낭비 x
* 정점들의 연결 정보를 확인하려 할 때는 간선의 개수만큼의 탐색이 필요 -> O(N) / N = 정점에 연결된 간선의 수
* 인접 행렬에 비해서 작업이 오래 걸림

# 그래프의 종류
## 무방향 그래프
* 간선에 방향이 존재 x

## 방향 그래프
* 간선에 방향이 존재, 간선의 방향대로만 이동 가능

## 가중치 그래프
* 간선에 가중치가 존재 / 정점 이동시 해당 가중치만큼의 비용이 필요

## 완전 그래프
* 모든 정점 사이에 간선이 존재

# 그래프 탐색
## 넓이 우선 탐색(BFS)
* 정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고 찾고자하는 정점을 만날 떄 까지 반복

## 깊이 우선 탐색(DFS)
* 정점을 기준으로 간선이 연결되어 있는 정점 들 중 하나를 선택해 이동하고 다시 이동한 정점을 기준으로 다시 인접 정점을 선택
* 연결되어있는 간선을 따라 찾고자 하는 정점을 만날 떄 까지 진행하고 찾기 못하면 다시 이전 정점으로 돌아와 반복
